title: 数据库范式以及求闭包、最小函数依赖集等
author: NEOLIN
tags: []
categories:
  - 软考
date: 2019-09-17 21:01:00
---
![mark](http://pxrwus83d.bkt.clouddn.com/neos-images/20190917/u6UPa5htj8Yn.png?imageslim)
<!-- more -->

#### 数据库范式

- 第一范式（1NF）： 在任意一个关系型数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。**第一范式指数据库表中的每一列都是不可分割的数据项**，同一列中不能有多个值。
- 第二范式（2NF）：第二范式是在第一范式的基础上建立起来的，满足第二范式必须先满足第一范式。第二范式要求其**非主属性必须完全依赖于关键字**。
- 第三范式（3NF）：第三范式必须先满足第二范式，并且**消除了传递依赖（也就是每个非主属性都不传递依赖于关键字）**
- BC范式（BCNF）：符合第三范式，**并且主属性不依赖于主属性。**
- 第四范式（4NF）：要求把同一张表中的多对多关系删除。

**函数依赖**：设X,Y是关系R的两个属性集合，存在 X→Y，若X' 是X的真子集，存在X'→Y，则称Y部分函数依赖于X，若不存在X'→Y，则称Y完全函数依赖于X。

**数据库闭包** ：闭包就是有一个属性直接或者间接推导出所有的属性集合。

例（1）：设有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)+

解： (1) 令X={AE}，X(0)=AE 

​        (2)在F中寻找尚未使用过的左边是AE的子集的函数依赖，结果是: A→D， E→C；所以 X(1)=X(0)DC=ACDE， 显然 X(1)≠X(0). 

​         (3) 在F中寻找尚未使用过的左边是ACDE的子集的函数依赖， 结果是: CD→I；所以 X(2)=X(1)I=ACDEI。虽然X（2）≠X(1)，但F中寻找尚未使用过函数依赖的左边已经没有X（2）的子集，所以不必再计算下去，即(AE)+=ACDEI。

例如：f={a->b，b->c，a->d，e->f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}

###### 候选码的求解理论和算法

对于给定的关系R（A1，A2，…An）和函数依赖集F，可将其属性分为4类：

- **L类**  仅出现在函数依赖左部的属性。
- **R 类**  仅出现在函数依赖右部的属性。
- **N 类**  在函数依赖左右两边均未出现的属性。
- **LR类**  在函数依赖左右两边均出现的属性。

**定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，则X必为R的任一候选码的成员。**

**推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类属性，且X+包含了R的全部属性；则X必为R的唯一候选码。**



```
例（2）：设有关系模式R（A，B，C，D），其函数依赖集F={D→B，B →D，AD →B，AC →D}，求R的所有候选码。

解：考察F发现，A，C两属性是L类属性，所以AC必是R的候选码成员，又因为（AC）+=ABCD，所以AC是R的唯一候选码。

```

　　**定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是R类属性，则X不在任何候选码中。**

　　**定理：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是N类属性，则X必包含在R的任一候选码中。**

　　**推论：对于给定的关系模式R及其函数依赖集F，若X（X∈R）是L类和N类组成的属性集，且X+包含了R的全部属性；则X是R的唯一候选码。**

**具体的步骤：**

**算法描述**

**（1）将R 的所有属性分为L、R、LR 和N 四类，并令X 代表L、N 类，Y 代表LR 类。**

**(2)求X+。若X+包含了R 的全部属性，则即为R 的唯一候选码，转（5）；否则，转（3）。**

**（3）在Y 中取一属性A，求（XA）+ ，若它包含了R 的全部属性，则是候选码，转（4）；否则，调换一属性反复进行这一过程，直到试完所有Y 中的属性。**

**（4）如果已找出所有候选码，则转（5）；否则在Y 中依次取2 个、3 个、…，求它们的属性闭包，若其闭包包含R 的全部属性，则是候选码。** 

**（5）结束。**



#### 求最小函数依赖

1. 用分解法则 将函数依赖集F中的所有依赖右边化为单一元素
2. 去掉F中的多余函数依赖，从第一个函数依赖开始从F中去掉X→Y，然后在剩下对的函数依赖中求X的闭包X+，如果X+包含Y，则去掉该函数依赖，直到遍历整个函数依赖集。
3. 去掉各依赖左部多余的属性：对于F中每一个左端包含多个属性的X有A，选择X的每个子集Z,如果A属于Z的闭包,则用Z→A代替X→A

```
例题 关系模式R(U，F)中，U=ABCDEG，F={B→D，DG→C,BD→E,AG→B,ADG→BC}
求F的最小函数依赖集
```

**解**  

1. 将ADG→BC分解成ADG→B和ADG→C。F={B→D，DG→C,BD→E,AG→B,ADG→B,ADG→C}
2. （1）去掉B→D，则B+={B},保留

（2）去掉DG→C，则DG+={DG},保留

（3）去掉BD→E，则BD+={BD},保留

（4）去掉AG→B，则AG+={AG},保留

（5）去掉ADG→B，则ADG+={ABCDEG},包含B属性，删除

（6）去掉ADG→C，则ADG+={ABCDEG},包含C属性，删除

**得 F={B→D，DG→C,BD→E,AG→B}**

3. (1)DG→C  子集为{D,G} , D+={D}不包含C，G+={G}不包含C

(2),BD→E  子集为{B,D} , **B+={B,D,E}包含E,可以被简化为B→E**，D+={D}不包含E

(3)AG→B  子集为{A,G} , A+={A}不包含B，G+={G}不包含B

**得 F={B→D，DG→C,B→E,AG→B}**

#### 判断模式分解是否为无损连接

//TODO